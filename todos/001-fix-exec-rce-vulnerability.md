# Fix Remote Code Execution via exec() Fallback

**Status**: âœ… RESOLVED
**Priority**: ðŸ”´ P1 - CRITICAL
**Category**: Security
**Effort**: 4-6 hours
**Deadline**: Before next deployment
**Resolved Date**: 2025-10-17
**PR**: #13
**Commit**: 557e52b
**CVE**: CVE-2024-EXEC-001

## Problem

The code execution system falls back to Python's `exec()` when Docker is unavailable. Despite attempts at sandboxing, this is fundamentally unsafe and can be bypassed, allowing arbitrary code execution on the server.

## Location

`apps/api/views/code_execution.py:154`

## Current Code

```python
# Line 154 - CRITICAL VULNERABILITY
exec(code, safe_globals, {})
```

## Attack Vector

```python
# Attacker submits:
code = """
import os
os.system('cat /etc/passwd > /tmp/stolen.txt')
"""
# System executes with exec(code, safe_globals, {})
```

## Impact

- Full server compromise possible
- Data exfiltration
- Credential theft
- Lateral movement to other systems

## Solution

1. Remove the exec() fallback entirely
2. Make Docker mandatory for code execution
3. Add startup health check that fails if Docker unavailable
4. Return clear error message when Docker is down

## Implementation Steps

### Step 1: Remove exec() fallback

```python
# apps/api/views/code_execution.py
def execute_code(self, code):
    if not self.docker_available:
        raise ServiceUnavailable(
            "Code execution service is temporarily unavailable. "
            "Please try again later."
        )

    # Only Docker execution path remains
    return self.execute_in_docker(code)
```

### Step 2: Add startup health check

```python
# apps/api/services/code_execution_service.py
from django.core.checks import register, Error

@register()
def check_docker_availability(app_configs, **kwargs):
    errors = []
    try:
        import docker
        client = docker.from_env()
        client.ping()
    except Exception as e:
        errors.append(
            Error(
                'Docker is not available',
                hint='Code execution requires Docker to be running',
                obj='code_execution',
                id='security.E001',
            )
        )
    return errors
```

### Step 3: Update settings

```python
# learning_community/settings/base.py
CODE_EXECUTION_REQUIRE_DOCKER = True
```

### Step 4: Add user-facing error handling

```python
# apps/api/views/code_execution.py
from rest_framework.exceptions import ServiceUnavailable

class CodeExecutionView(APIView):
    def post(self, request):
        try:
            result = code_execution_service.execute(code)
            return Response(result)
        except DockerException:
            raise ServiceUnavailable(
                detail={
                    'error': 'Code execution temporarily unavailable',
                    'message': 'Our code execution service is currently offline. Please try again in a few moments.'
                }
            )
```

## Testing

```python
# tests/test_code_execution_security.py
def test_exec_fallback_removed(self):
    """Ensure exec() fallback has been removed"""
    # Simulate Docker unavailable
    with patch('docker.from_env', side_effect=DockerException):
        with self.assertRaises(ServiceUnavailable):
            execute_code("print('test')")

def test_docker_health_check(self):
    """Ensure startup fails if Docker unavailable"""
    from django.core import checks
    errors = checks.run_checks()
    # Should fail if Docker not running
```

## Verification

- [ ] exec() code path completely removed
- [ ] Docker health check added to system checks
- [ ] ServiceUnavailable exception returns proper error
- [ ] Tests added for Docker unavailability
- [ ] Documentation updated

## References

- OWASP: Code Injection
- CWE-94: Improper Control of Generation of Code
- Comprehensive Security Audit 2025, Finding #1
