"""
Security tests specifically for CVE-2024-EXEC-001 (RCE via exec() fallback).

These tests verify that the dangerous exec() fallback has been removed from
the code execution views, preventing Remote Code Execution vulnerabilities.
"""

import logging
from unittest.mock import patch
from django.test import TestCase
from django.contrib.auth import get_user_model
from rest_framework.test import APIClient
from rest_framework import status

User = get_user_model()
logger = logging.getLogger(__name__)


class RCEVulnerabilityFixTests(TestCase):
    """
    Test suite verifying CVE-2024-EXEC-001 has been fixed.

    The vulnerability was in apps/api/views/code_execution.py lines 103-177
    where exec() was used as a fallback when Docker failed.
    """

    def setUp(self):
        """Set up test user and API client."""
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        self.client = APIClient()
        self.client.force_authenticate(user=self.user)

    def test_exec_fallback_code_removed_from_views(self):
        """
        CRITICAL: Verify exec() fallback code has been physically removed.

        This test reads the actual source code and verifies the dangerous
        exec() block (originally lines 103-177) is no longer present.
        """
        import os

        # Read the actual view file
        views_path = os.path.join(
            os.path.dirname(__file__),
            '../views/code_execution.py'
        )

        with open(views_path, 'r') as f:
            source_code = f.read()

        # The old code had these specific markers
        dangerous_patterns = [
            'exec(code, safe_globals',  # The actual exec() call
            'Restricted exec as last resort',  # Comment from old code
            'safe_globals = {',  # The restricted globals dict
            '__builtins__',  # The builtins manipulation
        ]

        # None of these should be in the execute_code function anymore
        for pattern in dangerous_patterns:
            self.assertNotIn(pattern, source_code,
                           f"Dangerous pattern '{pattern}' still found in code! "
                           f"The exec() fallback may not have been fully removed.")

    def test_docker_unavailable_returns_503(self):
        """
        Verify that Docker unavailability returns 503, not exec() execution.

        When Docker fails, the system must return Service Unavailable,
        not fall back to dangerous exec() execution.
        """
        code_payload = {'code': 'print("test")'}

        # Simulate complete Docker failure
        with patch('apps.api.services.code_execution_service.get_code_executor') as mock:
            mock.side_effect = Exception("Docker completely unavailable")

            response = self.client.post('/api/v1/code-execution/', code_payload)

            # Must return 503 (not 200 which would mean execution succeeded)
            self.assertIn(
                response.status_code,
                [status.HTTP_503_SERVICE_UNAVAILABLE, status.HTTP_500_INTERNAL_SERVER_ERROR],
                "Should return error status when Docker unavailable, not execute code"
            )

            # Should have error message
            self.assertIn('error', response.data)

    def test_cve_documented_in_code(self):
        """
        Verify CVE-2024-EXEC-001 is documented in the codebase.

        This ensures future developers understand why exec() was removed.
        """
        import os

        files_to_check = [
            '../views/code_execution.py',
            '../services/code_execution_service.py',
        ]

        cve_found = False
        for file_path in files_to_check:
            full_path = os.path.join(os.path.dirname(__file__), file_path)
            if os.path.exists(full_path):
                with open(full_path, 'r') as f:
                    if 'CVE-2024-EXEC-001' in f.read():
                        cve_found = True
                        break

        self.assertTrue(cve_found,
                       "CVE-2024-EXEC-001 should be documented in the code")

    def test_security_comments_present(self):
        """
        Verify security-focused comments are in place.

        The code should have clear security warnings about Docker requirement.
        """
        import os

        views_path = os.path.join(
            os.path.dirname(__file__),
            '../views/code_execution.py'
        )

        with open(views_path, 'r') as f:
            source_code = f.read()

        # Should have security-focused comments
        security_markers = [
            'SECURITY',  # Security comments
            'Docker',  # Docker requirement
            'unavailable',  # Service unavailable handling
        ]

        for marker in security_markers:
            self.assertIn(marker, source_code,
                         f"Security marker '{marker}' should be in code")


class CodeExecutionServiceSecurityTests(TestCase):
    """Test that CodeExecutionService has no fallback executors."""

    def test_service_has_no_exec_fallback(self):
        """
        Verify CodeExecutionService doesn't fall back to exec().

        The service should only use Docker, with no fallback executors.
        """
        import os
        import re

        service_path = os.path.join(
            os.path.dirname(__file__),
            '../services/code_execution_service.py'
        )

        with open(service_path, 'r') as f:
            source_code = f.read()

        # Remove comments and docstrings
        source_code = re.sub(r'#.*$', '', source_code, flags=re.MULTILINE)
        source_code = re.sub(r'""".*?"""', '', source_code, flags=re.DOTALL)
        source_code = re.sub(r"'''.*?'''", '', source_code, flags=re.DOTALL)

        # Should NOT have fallback execution chains
        dangerous_patterns = [
            r'code_executor\.execute',  # Old fallback executor
            r'exec\s*\(',  # Direct exec calls
        ]

        for pattern in dangerous_patterns:
            matches = re.findall(pattern, source_code)
            # Note: If found, check if it's in a security comment/removed code
            # We expect 0 matches in actual executable code
            if matches and not any('removed' in m.lower() for m in matches):
                self.fail(f"Found potentially dangerous pattern: {pattern}")
